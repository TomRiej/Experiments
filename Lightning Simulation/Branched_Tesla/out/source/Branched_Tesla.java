/* autogenerated by Processing revision 1277 on 2021-10-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Branched_Tesla extends PApplet {

int numRootBranches = 2;
Branch[] rootBranches = new Branch[numRootBranches];

 public void setup() {
    /* size commented out by preprocessor */;
    frameRate(1);
    colorMode(HSB, 360, 100, 100);
    for (int i = 0; i < numRootBranches; i++) {
        rootBranches[i] = new Branch(400, 200, 0);
    }
}

 public void draw() {
    background(0);

    for (Branch branch : rootBranches) {
        // random direction for the arc to go towards
        PVector desiredDirectionVector = PVector.random2D();
        // create all the branches
        branch.saveArc(desiredDirectionVector);
        // calc the furthest point to use lerping
        float rootBranchFurthestDist = branch.calcFurthestDist();
        // draw the glow parts of the branch
        branch.drawArcGlow(5);
        // draw the main white part of the branch
    }
    // noLoop();
}
class Branch {
    PVector startCoords;
    int recursionDepth;
    Branch[] daughterBranches;
    int numDaughterBranches;
    int numElectrons;
    PVector[] electronPath;
    float theta;
    float plusMinusTheta = PI/16;

    Branch(int x, int y, int recDepth) {
        startCoords = new PVector(x, y);
        recursionDepth = recDepth;
        switch (recursionDepth) {
            case 0:
                numDaughterBranches = PApplet.parseInt(random(2, 5));
                numElectrons = 250;
                break;
            case 1:
                numDaughterBranches = PApplet.parseInt(random(1, 3));
                numElectrons = 50;
                break;
            case 2:
                numDaughterBranches = PApplet.parseInt(random(0, 1));
                numElectrons = 20;
                break;
            default:
                numDaughterBranches = 0;
        }
        // init electron path array for this branch
        electronPath = new PVector[numElectrons];

        // initialise daughter branch array
        if (numDaughterBranches != 0) {
            daughterBranches = new Branch[numDaughterBranches];
        }
    }

     public void saveArc(PVector desiredDirectionVector) {
        // make the main arc
        PVector curCoords = startCoords.copy();
        // PVector desiredDirectionVector = PVector.random2D();

        for (int i = 0; i < numElectrons; i++) {
            theta = random(-plusMinusTheta, plusMinusTheta);
            // add rotated vector
            curCoords.add(desiredDirectionVector.rotate(theta));
            electronPath[i] = curCoords.copy();
        }

        // for each branch: (zero will result in this loop never running)
        for (int i = 0; i < numDaughterBranches; i++) {
            // pick random starting electron
            PVector randomElectron = electronPath[PApplet.parseInt(random(0, electronPath.length-1))];
            // Initialise new branch off this electron
            daughterBranches[i] = new Branch(PApplet.parseInt(randomElectron.x), PApplet.parseInt(randomElectron.y), recursionDepth+1);
            // save the arc for this branch
            daughterBranches[i].saveArc(desiredDirectionVector.rotate(theta));
        }
    }

     public float calcFurthestDist() {
        return startCoords.dist(electronPath[electronPath.length-1]);
    }

     public void drawArcGlow(float startRadius) {
        noStroke();
        // draw the blue for the branches
        if (numDaughterBranches > 0) {
            for (Branch branch : daughterBranches) {
                branch.drawArcGlow(startRadius);
            }
        }


        for (int i = 0; i < numElectrons; i++) {
            PVector e = electronPath[i];
            // random blue colour
            fill(random(190,240), random(70,100), 100);
            // find the radius of the ellipse
            float radius = lerp(startRadius, 1, PApplet.parseFloat(i)/PApplet.parseFloat(numElectrons));

            ellipse(e.x, e.y, radius, radius);
        }
    }

     public void drawArcMain() {
        noStroke();
        // First the blue glow for all
        fill(random(190,240), random(70,100), 100);
        // draw each of the branches first
        // if (numDaughterBranches > 0) {
        //     for (Branch branch : daughterBranches) {
        //         branch.drawArc();
        //     }
        // }
        
        // draw the main path
        for (PVector e : electronPath) {
            ellipse(e.x, e.y, 2, 2);
        }
    }
}


  public void settings() { size(800, 400); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Branched_Tesla" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
